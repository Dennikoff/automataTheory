Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement_list single_statement
Rule 3     statement_list -> single_statement
Rule 4     single_statement -> declaration ENDSTR
Rule 5     single_statement -> setting ENDSTR
Rule 6     single_statement -> if
Rule 7     single_statement -> dowhile
Rule 8     single_statement -> function
Rule 9     single_statement -> callfunc ENDSTR
Rule 10    single_statement -> cmd ENDSTR
Rule 11    single_statement -> ENDSTR
Rule 12    declaration -> type var
Rule 13    type -> INT
Rule 14    type -> BOOL
Rule 15    type -> SHORT INT
Rule 16    type -> SHORT
Rule 17    var -> variable
Rule 18    var -> setting
Rule 19    var -> var COMMA var
Rule 20    setting -> variable SET expr
Rule 21    expr -> variable
Rule 22    expr -> const
Rule 23    expr -> math_expr
Rule 24    expr -> callfunc
Rule 25    expr -> cmd
Rule 26    expr -> OPBR expr CLBR
Rule 27    setting -> variable SET setarr
Rule 28    type -> vectorof
Rule 29    vectorof -> VECTOROF type
Rule 30    setarr -> CUOPBR setarr CUCLBR
Rule 31    setarr -> setarr COMMA setarr
Rule 32    setarr -> CUOPBR exprarr CUCLBR
Rule 33    exprarr -> exprarr COMMA exprarr
Rule 34    exprarr -> expr
Rule 35    const -> digit
Rule 36    const -> bool
Rule 37    const -> sizeof
Rule 38    variable -> VARIABLE
Rule 39    variable -> VARIABLE index
Rule 40    index -> SQOPBR expr SQCLBR
Rule 41    index -> index index
Rule 42    sizeof -> SIZEOF OPBR type CLBR
Rule 43    sizeof -> SIZEOF OPBR variable CLBR
Rule 44    bool -> TRUE
Rule 45    bool -> FALSE
Rule 46    bool -> UNDEFINED
Rule 47    digit -> INTTYP
Rule 48    digit -> SHORTTYP
Rule 49    math_expr -> expr SUB expr
Rule 50    math_expr -> expr ADD expr
Rule 51    math_expr -> expr SECOND LARGER expr
Rule 52    math_expr -> expr SECOND SMALLER expr
Rule 53    math_expr -> expr FIRST LARGER expr
Rule 54    math_expr -> expr FIRST SMALLER expr
Rule 55    math_expr -> expr AND expr
Rule 56    math_expr -> expr OR expr
Rule 57    math_expr -> expr NOT AND expr
Rule 58    math_expr -> expr NOT OR expr
Rule 59    callfunc -> VARIABLE OPBR varlist CLBR
Rule 60    varlist -> variable
Rule 61    varlist -> const
Rule 62    varlist -> varlist COMMA varlist
Rule 63    if -> IF expr THEN statement_gr ELSE statement_gr
Rule 64    if -> IF expr THEN statement_gr error
Rule 65    if -> IF expr error
Rule 66    statement_gr -> BEGIN statement_list END
Rule 67    statement_gr -> single_statement
Rule 68    dowhile -> DO statement_gr WHILE expr ENDSTR
Rule 69    dowhile -> DO error
Rule 70    function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR
Rule 71    arrtype -> type VARIABLE
Rule 72    arrtype -> arrtype COMMA arrtype
Rule 73    cmd -> MOVE
Rule 74    cmd -> MOVE dir
Rule 75    cmd -> RIGHT
Rule 76    cmd -> LEFT
Rule 77    cmd -> LMS
Rule 78    dir -> RIGHT
Rule 79    dir -> LEFT

Terminals, with rules where they appear

ADD                  : 50
AND                  : 55 57
BEGIN                : 66
BOOL                 : 14
CLBR                 : 26 42 43 59 70
COMMA                : 19 31 33 62 72
CUCLBR               : 30 32
CUOPBR               : 30 32
DO                   : 68 69
ELSE                 : 63
END                  : 66
ENDSTR               : 4 5 9 10 11 68 70
FALSE                : 45
FIRST                : 53 54
FUNCTION             : 70
IF                   : 63 64 65
INT                  : 13 15
INTTYP               : 47
LARGER               : 51 53
LEFT                 : 76 79
LMS                  : 77
MOVE                 : 73 74
NEWLINE              : 
NOT                  : 57 58
OPBR                 : 26 42 43 59 70
OR                   : 56 58
RETURN               : 70
RIGHT                : 75 78
SECOND               : 51 52
SET                  : 20 27
SHORT                : 15 16
SHORTTYP             : 48
SIZEOF               : 42 43
SMALLER              : 52 54
SQCLBR               : 40
SQOPBR               : 40
SUB                  : 49
THEN                 : 63 64
TRUE                 : 44
UNDEFINED            : 46
VARIABLE             : 38 39 59 70 71
VECTOROF             : 29
WHILE                : 68
error                : 64 65 69

Nonterminals, with rules where they appear

arrtype              : 70 72 72
bool                 : 36
callfunc             : 9 24
cmd                  : 10 25
const                : 22 61
declaration          : 4
digit                : 35
dir                  : 74
dowhile              : 7
expr                 : 20 26 34 40 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 63 64 65 68 70
exprarr              : 32 33 33
function             : 8
if                   : 6
index                : 39 41 41
math_expr            : 23
program              : 0
setarr               : 27 30 31 31
setting              : 5 18
single_statement     : 2 3 67
sizeof               : 37
statement_gr         : 63 63 64 68 70
statement_list       : 1 2 66
type                 : 12 29 42 71
var                  : 12 19 19
variable             : 17 20 21 27 43 60
varlist              : 59 62 62
vectorof             : 28

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement_list single_statement
    (3) statement_list -> . single_statement
    (4) single_statement -> . declaration ENDSTR
    (5) single_statement -> . setting ENDSTR
    (6) single_statement -> . if
    (7) single_statement -> . dowhile
    (8) single_statement -> . function
    (9) single_statement -> . callfunc ENDSTR
    (10) single_statement -> . cmd ENDSTR
    (11) single_statement -> . ENDSTR
    (12) declaration -> . type var
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr
    (63) if -> . IF expr THEN statement_gr ELSE statement_gr
    (64) if -> . IF expr THEN statement_gr error
    (65) if -> . IF expr error
    (68) dowhile -> . DO statement_gr WHILE expr ENDSTR
    (69) dowhile -> . DO error
    (70) function -> . FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (29) vectorof -> . VECTOROF type

    ENDSTR          shift and go to state 5
    IF              shift and go to state 14
    DO              shift and go to state 15
    FUNCTION        shift and go to state 16
    VARIABLE        shift and go to state 17
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    single_statement               shift and go to state 3
    declaration                    shift and go to state 4
    setting                        shift and go to state 6
    if                             shift and go to state 7
    dowhile                        shift and go to state 8
    function                       shift and go to state 9
    callfunc                       shift and go to state 10
    cmd                            shift and go to state 11
    type                           shift and go to state 12
    variable                       shift and go to state 13
    vectorof                       shift and go to state 25

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (2) statement_list -> statement_list . single_statement
    (4) single_statement -> . declaration ENDSTR
    (5) single_statement -> . setting ENDSTR
    (6) single_statement -> . if
    (7) single_statement -> . dowhile
    (8) single_statement -> . function
    (9) single_statement -> . callfunc ENDSTR
    (10) single_statement -> . cmd ENDSTR
    (11) single_statement -> . ENDSTR
    (12) declaration -> . type var
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr
    (63) if -> . IF expr THEN statement_gr ELSE statement_gr
    (64) if -> . IF expr THEN statement_gr error
    (65) if -> . IF expr error
    (68) dowhile -> . DO statement_gr WHILE expr ENDSTR
    (69) dowhile -> . DO error
    (70) function -> . FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (29) vectorof -> . VECTOROF type

    $end            reduce using rule 1 (program -> statement_list .)
    ENDSTR          shift and go to state 5
    IF              shift and go to state 14
    DO              shift and go to state 15
    FUNCTION        shift and go to state 16
    VARIABLE        shift and go to state 17
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    single_statement               shift and go to state 27
    declaration                    shift and go to state 4
    setting                        shift and go to state 6
    if                             shift and go to state 7
    dowhile                        shift and go to state 8
    function                       shift and go to state 9
    callfunc                       shift and go to state 10
    cmd                            shift and go to state 11
    type                           shift and go to state 12
    variable                       shift and go to state 13
    vectorof                       shift and go to state 25

state 3

    (3) statement_list -> single_statement .

    ENDSTR          reduce using rule 3 (statement_list -> single_statement .)
    IF              reduce using rule 3 (statement_list -> single_statement .)
    DO              reduce using rule 3 (statement_list -> single_statement .)
    FUNCTION        reduce using rule 3 (statement_list -> single_statement .)
    VARIABLE        reduce using rule 3 (statement_list -> single_statement .)
    MOVE            reduce using rule 3 (statement_list -> single_statement .)
    RIGHT           reduce using rule 3 (statement_list -> single_statement .)
    LEFT            reduce using rule 3 (statement_list -> single_statement .)
    LMS             reduce using rule 3 (statement_list -> single_statement .)
    INT             reduce using rule 3 (statement_list -> single_statement .)
    BOOL            reduce using rule 3 (statement_list -> single_statement .)
    SHORT           reduce using rule 3 (statement_list -> single_statement .)
    VECTOROF        reduce using rule 3 (statement_list -> single_statement .)
    $end            reduce using rule 3 (statement_list -> single_statement .)
    END             reduce using rule 3 (statement_list -> single_statement .)


state 4

    (4) single_statement -> declaration . ENDSTR

    ENDSTR          shift and go to state 28


state 5

    (11) single_statement -> ENDSTR .

    ENDSTR          reduce using rule 11 (single_statement -> ENDSTR .)
    IF              reduce using rule 11 (single_statement -> ENDSTR .)
    DO              reduce using rule 11 (single_statement -> ENDSTR .)
    FUNCTION        reduce using rule 11 (single_statement -> ENDSTR .)
    VARIABLE        reduce using rule 11 (single_statement -> ENDSTR .)
    MOVE            reduce using rule 11 (single_statement -> ENDSTR .)
    RIGHT           reduce using rule 11 (single_statement -> ENDSTR .)
    LEFT            reduce using rule 11 (single_statement -> ENDSTR .)
    LMS             reduce using rule 11 (single_statement -> ENDSTR .)
    INT             reduce using rule 11 (single_statement -> ENDSTR .)
    BOOL            reduce using rule 11 (single_statement -> ENDSTR .)
    SHORT           reduce using rule 11 (single_statement -> ENDSTR .)
    VECTOROF        reduce using rule 11 (single_statement -> ENDSTR .)
    $end            reduce using rule 11 (single_statement -> ENDSTR .)
    WHILE           reduce using rule 11 (single_statement -> ENDSTR .)
    END             reduce using rule 11 (single_statement -> ENDSTR .)
    ELSE            reduce using rule 11 (single_statement -> ENDSTR .)
    error           reduce using rule 11 (single_statement -> ENDSTR .)
    RETURN          reduce using rule 11 (single_statement -> ENDSTR .)


state 6

    (5) single_statement -> setting . ENDSTR

    ENDSTR          shift and go to state 29


state 7

    (6) single_statement -> if .

    ENDSTR          reduce using rule 6 (single_statement -> if .)
    IF              reduce using rule 6 (single_statement -> if .)
    DO              reduce using rule 6 (single_statement -> if .)
    FUNCTION        reduce using rule 6 (single_statement -> if .)
    VARIABLE        reduce using rule 6 (single_statement -> if .)
    MOVE            reduce using rule 6 (single_statement -> if .)
    RIGHT           reduce using rule 6 (single_statement -> if .)
    LEFT            reduce using rule 6 (single_statement -> if .)
    LMS             reduce using rule 6 (single_statement -> if .)
    INT             reduce using rule 6 (single_statement -> if .)
    BOOL            reduce using rule 6 (single_statement -> if .)
    SHORT           reduce using rule 6 (single_statement -> if .)
    VECTOROF        reduce using rule 6 (single_statement -> if .)
    $end            reduce using rule 6 (single_statement -> if .)
    WHILE           reduce using rule 6 (single_statement -> if .)
    END             reduce using rule 6 (single_statement -> if .)
    ELSE            reduce using rule 6 (single_statement -> if .)
    error           reduce using rule 6 (single_statement -> if .)
    RETURN          reduce using rule 6 (single_statement -> if .)


state 8

    (7) single_statement -> dowhile .

    ENDSTR          reduce using rule 7 (single_statement -> dowhile .)
    IF              reduce using rule 7 (single_statement -> dowhile .)
    DO              reduce using rule 7 (single_statement -> dowhile .)
    FUNCTION        reduce using rule 7 (single_statement -> dowhile .)
    VARIABLE        reduce using rule 7 (single_statement -> dowhile .)
    MOVE            reduce using rule 7 (single_statement -> dowhile .)
    RIGHT           reduce using rule 7 (single_statement -> dowhile .)
    LEFT            reduce using rule 7 (single_statement -> dowhile .)
    LMS             reduce using rule 7 (single_statement -> dowhile .)
    INT             reduce using rule 7 (single_statement -> dowhile .)
    BOOL            reduce using rule 7 (single_statement -> dowhile .)
    SHORT           reduce using rule 7 (single_statement -> dowhile .)
    VECTOROF        reduce using rule 7 (single_statement -> dowhile .)
    $end            reduce using rule 7 (single_statement -> dowhile .)
    WHILE           reduce using rule 7 (single_statement -> dowhile .)
    END             reduce using rule 7 (single_statement -> dowhile .)
    ELSE            reduce using rule 7 (single_statement -> dowhile .)
    error           reduce using rule 7 (single_statement -> dowhile .)
    RETURN          reduce using rule 7 (single_statement -> dowhile .)


state 9

    (8) single_statement -> function .

    ENDSTR          reduce using rule 8 (single_statement -> function .)
    IF              reduce using rule 8 (single_statement -> function .)
    DO              reduce using rule 8 (single_statement -> function .)
    FUNCTION        reduce using rule 8 (single_statement -> function .)
    VARIABLE        reduce using rule 8 (single_statement -> function .)
    MOVE            reduce using rule 8 (single_statement -> function .)
    RIGHT           reduce using rule 8 (single_statement -> function .)
    LEFT            reduce using rule 8 (single_statement -> function .)
    LMS             reduce using rule 8 (single_statement -> function .)
    INT             reduce using rule 8 (single_statement -> function .)
    BOOL            reduce using rule 8 (single_statement -> function .)
    SHORT           reduce using rule 8 (single_statement -> function .)
    VECTOROF        reduce using rule 8 (single_statement -> function .)
    $end            reduce using rule 8 (single_statement -> function .)
    WHILE           reduce using rule 8 (single_statement -> function .)
    END             reduce using rule 8 (single_statement -> function .)
    ELSE            reduce using rule 8 (single_statement -> function .)
    error           reduce using rule 8 (single_statement -> function .)
    RETURN          reduce using rule 8 (single_statement -> function .)


state 10

    (9) single_statement -> callfunc . ENDSTR

    ENDSTR          shift and go to state 30


state 11

    (10) single_statement -> cmd . ENDSTR

    ENDSTR          shift and go to state 31


state 12

    (12) declaration -> type . var
    (17) var -> . variable
    (18) var -> . setting
    (19) var -> . var COMMA var
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr

    VARIABLE        shift and go to state 35

    var                            shift and go to state 32
    variable                       shift and go to state 33
    setting                        shift and go to state 34

state 13

    (20) setting -> variable . SET expr
    (27) setting -> variable . SET setarr

    SET             shift and go to state 36


state 14

    (63) if -> IF . expr THEN statement_gr ELSE statement_gr
    (64) if -> IF . expr THEN statement_gr error
    (65) if -> IF . expr error
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 37
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 15

    (68) dowhile -> DO . statement_gr WHILE expr ENDSTR
    (69) dowhile -> DO . error
    (66) statement_gr -> . BEGIN statement_list END
    (67) statement_gr -> . single_statement
    (4) single_statement -> . declaration ENDSTR
    (5) single_statement -> . setting ENDSTR
    (6) single_statement -> . if
    (7) single_statement -> . dowhile
    (8) single_statement -> . function
    (9) single_statement -> . callfunc ENDSTR
    (10) single_statement -> . cmd ENDSTR
    (11) single_statement -> . ENDSTR
    (12) declaration -> . type var
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr
    (63) if -> . IF expr THEN statement_gr ELSE statement_gr
    (64) if -> . IF expr THEN statement_gr error
    (65) if -> . IF expr error
    (68) dowhile -> . DO statement_gr WHILE expr ENDSTR
    (69) dowhile -> . DO error
    (70) function -> . FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (29) vectorof -> . VECTOROF type

    error           shift and go to state 55
    BEGIN           shift and go to state 56
    ENDSTR          shift and go to state 5
    IF              shift and go to state 14
    DO              shift and go to state 15
    FUNCTION        shift and go to state 16
    VARIABLE        shift and go to state 17
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    statement_gr                   shift and go to state 54
    single_statement               shift and go to state 57
    declaration                    shift and go to state 4
    setting                        shift and go to state 6
    if                             shift and go to state 7
    dowhile                        shift and go to state 8
    function                       shift and go to state 9
    callfunc                       shift and go to state 10
    cmd                            shift and go to state 11
    type                           shift and go to state 12
    variable                       shift and go to state 13
    vectorof                       shift and go to state 25

state 16

    (70) function -> FUNCTION . VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR

    VARIABLE        shift and go to state 58


state 17

    (59) callfunc -> VARIABLE . OPBR varlist CLBR
    (38) variable -> VARIABLE .
    (39) variable -> VARIABLE . index
    (40) index -> . SQOPBR expr SQCLBR
    (41) index -> . index index

    OPBR            shift and go to state 59
    SET             reduce using rule 38 (variable -> VARIABLE .)
    SQOPBR          shift and go to state 61

    index                          shift and go to state 60

state 18

    (73) cmd -> MOVE .
    (74) cmd -> MOVE . dir
    (78) dir -> . RIGHT
    (79) dir -> . LEFT

    ENDSTR          reduce using rule 73 (cmd -> MOVE .)
    THEN            reduce using rule 73 (cmd -> MOVE .)
    error           reduce using rule 73 (cmd -> MOVE .)
    SUB             reduce using rule 73 (cmd -> MOVE .)
    ADD             reduce using rule 73 (cmd -> MOVE .)
    SECOND          reduce using rule 73 (cmd -> MOVE .)
    FIRST           reduce using rule 73 (cmd -> MOVE .)
    AND             reduce using rule 73 (cmd -> MOVE .)
    OR              reduce using rule 73 (cmd -> MOVE .)
    NOT             reduce using rule 73 (cmd -> MOVE .)
    COMMA           reduce using rule 73 (cmd -> MOVE .)
    CLBR            reduce using rule 73 (cmd -> MOVE .)
    SQCLBR          reduce using rule 73 (cmd -> MOVE .)
    CUCLBR          reduce using rule 73 (cmd -> MOVE .)
    RIGHT           shift and go to state 63
    LEFT            shift and go to state 64

    dir                            shift and go to state 62

state 19

    (75) cmd -> RIGHT .

    ENDSTR          reduce using rule 75 (cmd -> RIGHT .)
    THEN            reduce using rule 75 (cmd -> RIGHT .)
    error           reduce using rule 75 (cmd -> RIGHT .)
    SUB             reduce using rule 75 (cmd -> RIGHT .)
    ADD             reduce using rule 75 (cmd -> RIGHT .)
    SECOND          reduce using rule 75 (cmd -> RIGHT .)
    FIRST           reduce using rule 75 (cmd -> RIGHT .)
    AND             reduce using rule 75 (cmd -> RIGHT .)
    OR              reduce using rule 75 (cmd -> RIGHT .)
    NOT             reduce using rule 75 (cmd -> RIGHT .)
    COMMA           reduce using rule 75 (cmd -> RIGHT .)
    CLBR            reduce using rule 75 (cmd -> RIGHT .)
    SQCLBR          reduce using rule 75 (cmd -> RIGHT .)
    CUCLBR          reduce using rule 75 (cmd -> RIGHT .)


state 20

    (76) cmd -> LEFT .

    ENDSTR          reduce using rule 76 (cmd -> LEFT .)
    THEN            reduce using rule 76 (cmd -> LEFT .)
    error           reduce using rule 76 (cmd -> LEFT .)
    SUB             reduce using rule 76 (cmd -> LEFT .)
    ADD             reduce using rule 76 (cmd -> LEFT .)
    SECOND          reduce using rule 76 (cmd -> LEFT .)
    FIRST           reduce using rule 76 (cmd -> LEFT .)
    AND             reduce using rule 76 (cmd -> LEFT .)
    OR              reduce using rule 76 (cmd -> LEFT .)
    NOT             reduce using rule 76 (cmd -> LEFT .)
    COMMA           reduce using rule 76 (cmd -> LEFT .)
    CLBR            reduce using rule 76 (cmd -> LEFT .)
    SQCLBR          reduce using rule 76 (cmd -> LEFT .)
    CUCLBR          reduce using rule 76 (cmd -> LEFT .)


state 21

    (77) cmd -> LMS .

    ENDSTR          reduce using rule 77 (cmd -> LMS .)
    THEN            reduce using rule 77 (cmd -> LMS .)
    error           reduce using rule 77 (cmd -> LMS .)
    SUB             reduce using rule 77 (cmd -> LMS .)
    ADD             reduce using rule 77 (cmd -> LMS .)
    SECOND          reduce using rule 77 (cmd -> LMS .)
    FIRST           reduce using rule 77 (cmd -> LMS .)
    AND             reduce using rule 77 (cmd -> LMS .)
    OR              reduce using rule 77 (cmd -> LMS .)
    NOT             reduce using rule 77 (cmd -> LMS .)
    COMMA           reduce using rule 77 (cmd -> LMS .)
    CLBR            reduce using rule 77 (cmd -> LMS .)
    SQCLBR          reduce using rule 77 (cmd -> LMS .)
    CUCLBR          reduce using rule 77 (cmd -> LMS .)


state 22

    (13) type -> INT .

    VARIABLE        reduce using rule 13 (type -> INT .)
    CLBR            reduce using rule 13 (type -> INT .)


state 23

    (14) type -> BOOL .

    VARIABLE        reduce using rule 14 (type -> BOOL .)
    CLBR            reduce using rule 14 (type -> BOOL .)


state 24

    (15) type -> SHORT . INT
    (16) type -> SHORT .

    INT             shift and go to state 65
    VARIABLE        reduce using rule 16 (type -> SHORT .)
    CLBR            reduce using rule 16 (type -> SHORT .)


state 25

    (28) type -> vectorof .

    VARIABLE        reduce using rule 28 (type -> vectorof .)
    CLBR            reduce using rule 28 (type -> vectorof .)


state 26

    (29) vectorof -> VECTOROF . type
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (29) vectorof -> . VECTOROF type

    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    type                           shift and go to state 66
    vectorof                       shift and go to state 25

state 27

    (2) statement_list -> statement_list single_statement .

    ENDSTR          reduce using rule 2 (statement_list -> statement_list single_statement .)
    IF              reduce using rule 2 (statement_list -> statement_list single_statement .)
    DO              reduce using rule 2 (statement_list -> statement_list single_statement .)
    FUNCTION        reduce using rule 2 (statement_list -> statement_list single_statement .)
    VARIABLE        reduce using rule 2 (statement_list -> statement_list single_statement .)
    MOVE            reduce using rule 2 (statement_list -> statement_list single_statement .)
    RIGHT           reduce using rule 2 (statement_list -> statement_list single_statement .)
    LEFT            reduce using rule 2 (statement_list -> statement_list single_statement .)
    LMS             reduce using rule 2 (statement_list -> statement_list single_statement .)
    INT             reduce using rule 2 (statement_list -> statement_list single_statement .)
    BOOL            reduce using rule 2 (statement_list -> statement_list single_statement .)
    SHORT           reduce using rule 2 (statement_list -> statement_list single_statement .)
    VECTOROF        reduce using rule 2 (statement_list -> statement_list single_statement .)
    $end            reduce using rule 2 (statement_list -> statement_list single_statement .)
    END             reduce using rule 2 (statement_list -> statement_list single_statement .)


state 28

    (4) single_statement -> declaration ENDSTR .

    ENDSTR          reduce using rule 4 (single_statement -> declaration ENDSTR .)
    IF              reduce using rule 4 (single_statement -> declaration ENDSTR .)
    DO              reduce using rule 4 (single_statement -> declaration ENDSTR .)
    FUNCTION        reduce using rule 4 (single_statement -> declaration ENDSTR .)
    VARIABLE        reduce using rule 4 (single_statement -> declaration ENDSTR .)
    MOVE            reduce using rule 4 (single_statement -> declaration ENDSTR .)
    RIGHT           reduce using rule 4 (single_statement -> declaration ENDSTR .)
    LEFT            reduce using rule 4 (single_statement -> declaration ENDSTR .)
    LMS             reduce using rule 4 (single_statement -> declaration ENDSTR .)
    INT             reduce using rule 4 (single_statement -> declaration ENDSTR .)
    BOOL            reduce using rule 4 (single_statement -> declaration ENDSTR .)
    SHORT           reduce using rule 4 (single_statement -> declaration ENDSTR .)
    VECTOROF        reduce using rule 4 (single_statement -> declaration ENDSTR .)
    $end            reduce using rule 4 (single_statement -> declaration ENDSTR .)
    WHILE           reduce using rule 4 (single_statement -> declaration ENDSTR .)
    END             reduce using rule 4 (single_statement -> declaration ENDSTR .)
    ELSE            reduce using rule 4 (single_statement -> declaration ENDSTR .)
    error           reduce using rule 4 (single_statement -> declaration ENDSTR .)
    RETURN          reduce using rule 4 (single_statement -> declaration ENDSTR .)


state 29

    (5) single_statement -> setting ENDSTR .

    ENDSTR          reduce using rule 5 (single_statement -> setting ENDSTR .)
    IF              reduce using rule 5 (single_statement -> setting ENDSTR .)
    DO              reduce using rule 5 (single_statement -> setting ENDSTR .)
    FUNCTION        reduce using rule 5 (single_statement -> setting ENDSTR .)
    VARIABLE        reduce using rule 5 (single_statement -> setting ENDSTR .)
    MOVE            reduce using rule 5 (single_statement -> setting ENDSTR .)
    RIGHT           reduce using rule 5 (single_statement -> setting ENDSTR .)
    LEFT            reduce using rule 5 (single_statement -> setting ENDSTR .)
    LMS             reduce using rule 5 (single_statement -> setting ENDSTR .)
    INT             reduce using rule 5 (single_statement -> setting ENDSTR .)
    BOOL            reduce using rule 5 (single_statement -> setting ENDSTR .)
    SHORT           reduce using rule 5 (single_statement -> setting ENDSTR .)
    VECTOROF        reduce using rule 5 (single_statement -> setting ENDSTR .)
    $end            reduce using rule 5 (single_statement -> setting ENDSTR .)
    WHILE           reduce using rule 5 (single_statement -> setting ENDSTR .)
    END             reduce using rule 5 (single_statement -> setting ENDSTR .)
    ELSE            reduce using rule 5 (single_statement -> setting ENDSTR .)
    error           reduce using rule 5 (single_statement -> setting ENDSTR .)
    RETURN          reduce using rule 5 (single_statement -> setting ENDSTR .)


state 30

    (9) single_statement -> callfunc ENDSTR .

    ENDSTR          reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    IF              reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    DO              reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    FUNCTION        reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    VARIABLE        reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    MOVE            reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    RIGHT           reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    LEFT            reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    LMS             reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    INT             reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    BOOL            reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    SHORT           reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    VECTOROF        reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    $end            reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    WHILE           reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    END             reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    ELSE            reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    error           reduce using rule 9 (single_statement -> callfunc ENDSTR .)
    RETURN          reduce using rule 9 (single_statement -> callfunc ENDSTR .)


state 31

    (10) single_statement -> cmd ENDSTR .

    ENDSTR          reduce using rule 10 (single_statement -> cmd ENDSTR .)
    IF              reduce using rule 10 (single_statement -> cmd ENDSTR .)
    DO              reduce using rule 10 (single_statement -> cmd ENDSTR .)
    FUNCTION        reduce using rule 10 (single_statement -> cmd ENDSTR .)
    VARIABLE        reduce using rule 10 (single_statement -> cmd ENDSTR .)
    MOVE            reduce using rule 10 (single_statement -> cmd ENDSTR .)
    RIGHT           reduce using rule 10 (single_statement -> cmd ENDSTR .)
    LEFT            reduce using rule 10 (single_statement -> cmd ENDSTR .)
    LMS             reduce using rule 10 (single_statement -> cmd ENDSTR .)
    INT             reduce using rule 10 (single_statement -> cmd ENDSTR .)
    BOOL            reduce using rule 10 (single_statement -> cmd ENDSTR .)
    SHORT           reduce using rule 10 (single_statement -> cmd ENDSTR .)
    VECTOROF        reduce using rule 10 (single_statement -> cmd ENDSTR .)
    $end            reduce using rule 10 (single_statement -> cmd ENDSTR .)
    WHILE           reduce using rule 10 (single_statement -> cmd ENDSTR .)
    END             reduce using rule 10 (single_statement -> cmd ENDSTR .)
    ELSE            reduce using rule 10 (single_statement -> cmd ENDSTR .)
    error           reduce using rule 10 (single_statement -> cmd ENDSTR .)
    RETURN          reduce using rule 10 (single_statement -> cmd ENDSTR .)


state 32

    (12) declaration -> type var .
    (19) var -> var . COMMA var

    ENDSTR          reduce using rule 12 (declaration -> type var .)
    COMMA           shift and go to state 67


state 33

    (17) var -> variable .
    (20) setting -> variable . SET expr
    (27) setting -> variable . SET setarr

    COMMA           reduce using rule 17 (var -> variable .)
    ENDSTR          reduce using rule 17 (var -> variable .)
    SET             shift and go to state 36


state 34

    (18) var -> setting .

    COMMA           reduce using rule 18 (var -> setting .)
    ENDSTR          reduce using rule 18 (var -> setting .)


state 35

    (38) variable -> VARIABLE .
    (39) variable -> VARIABLE . index
    (40) index -> . SQOPBR expr SQCLBR
    (41) index -> . index index

    SET             reduce using rule 38 (variable -> VARIABLE .)
    COMMA           reduce using rule 38 (variable -> VARIABLE .)
    ENDSTR          reduce using rule 38 (variable -> VARIABLE .)
    CLBR            reduce using rule 38 (variable -> VARIABLE .)
    SQOPBR          shift and go to state 61

    index                          shift and go to state 60

state 36

    (20) setting -> variable SET . expr
    (27) setting -> variable SET . setarr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (30) setarr -> . CUOPBR setarr CUCLBR
    (31) setarr -> . setarr COMMA setarr
    (32) setarr -> . CUOPBR exprarr CUCLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    CUOPBR          shift and go to state 70
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    variable                       shift and go to state 38
    expr                           shift and go to state 68
    setarr                         shift and go to state 69
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 37

    (63) if -> IF expr . THEN statement_gr ELSE statement_gr
    (64) if -> IF expr . THEN statement_gr error
    (65) if -> IF expr . error
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

    THEN            shift and go to state 71
    error           shift and go to state 72
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79


state 38

    (21) expr -> variable .

    THEN            reduce using rule 21 (expr -> variable .)
    error           reduce using rule 21 (expr -> variable .)
    SUB             reduce using rule 21 (expr -> variable .)
    ADD             reduce using rule 21 (expr -> variable .)
    SECOND          reduce using rule 21 (expr -> variable .)
    FIRST           reduce using rule 21 (expr -> variable .)
    AND             reduce using rule 21 (expr -> variable .)
    OR              reduce using rule 21 (expr -> variable .)
    NOT             reduce using rule 21 (expr -> variable .)
    ENDSTR          reduce using rule 21 (expr -> variable .)
    COMMA           reduce using rule 21 (expr -> variable .)
    CLBR            reduce using rule 21 (expr -> variable .)
    SQCLBR          reduce using rule 21 (expr -> variable .)
    CUCLBR          reduce using rule 21 (expr -> variable .)


state 39

    (22) expr -> const .

    THEN            reduce using rule 22 (expr -> const .)
    error           reduce using rule 22 (expr -> const .)
    SUB             reduce using rule 22 (expr -> const .)
    ADD             reduce using rule 22 (expr -> const .)
    SECOND          reduce using rule 22 (expr -> const .)
    FIRST           reduce using rule 22 (expr -> const .)
    AND             reduce using rule 22 (expr -> const .)
    OR              reduce using rule 22 (expr -> const .)
    NOT             reduce using rule 22 (expr -> const .)
    ENDSTR          reduce using rule 22 (expr -> const .)
    COMMA           reduce using rule 22 (expr -> const .)
    CLBR            reduce using rule 22 (expr -> const .)
    SQCLBR          reduce using rule 22 (expr -> const .)
    CUCLBR          reduce using rule 22 (expr -> const .)


state 40

    (23) expr -> math_expr .

    THEN            reduce using rule 23 (expr -> math_expr .)
    error           reduce using rule 23 (expr -> math_expr .)
    SUB             reduce using rule 23 (expr -> math_expr .)
    ADD             reduce using rule 23 (expr -> math_expr .)
    SECOND          reduce using rule 23 (expr -> math_expr .)
    FIRST           reduce using rule 23 (expr -> math_expr .)
    AND             reduce using rule 23 (expr -> math_expr .)
    OR              reduce using rule 23 (expr -> math_expr .)
    NOT             reduce using rule 23 (expr -> math_expr .)
    ENDSTR          reduce using rule 23 (expr -> math_expr .)
    COMMA           reduce using rule 23 (expr -> math_expr .)
    CLBR            reduce using rule 23 (expr -> math_expr .)
    SQCLBR          reduce using rule 23 (expr -> math_expr .)
    CUCLBR          reduce using rule 23 (expr -> math_expr .)


state 41

    (24) expr -> callfunc .

    THEN            reduce using rule 24 (expr -> callfunc .)
    error           reduce using rule 24 (expr -> callfunc .)
    SUB             reduce using rule 24 (expr -> callfunc .)
    ADD             reduce using rule 24 (expr -> callfunc .)
    SECOND          reduce using rule 24 (expr -> callfunc .)
    FIRST           reduce using rule 24 (expr -> callfunc .)
    AND             reduce using rule 24 (expr -> callfunc .)
    OR              reduce using rule 24 (expr -> callfunc .)
    NOT             reduce using rule 24 (expr -> callfunc .)
    ENDSTR          reduce using rule 24 (expr -> callfunc .)
    COMMA           reduce using rule 24 (expr -> callfunc .)
    CLBR            reduce using rule 24 (expr -> callfunc .)
    SQCLBR          reduce using rule 24 (expr -> callfunc .)
    CUCLBR          reduce using rule 24 (expr -> callfunc .)


state 42

    (25) expr -> cmd .

    THEN            reduce using rule 25 (expr -> cmd .)
    error           reduce using rule 25 (expr -> cmd .)
    SUB             reduce using rule 25 (expr -> cmd .)
    ADD             reduce using rule 25 (expr -> cmd .)
    SECOND          reduce using rule 25 (expr -> cmd .)
    FIRST           reduce using rule 25 (expr -> cmd .)
    AND             reduce using rule 25 (expr -> cmd .)
    OR              reduce using rule 25 (expr -> cmd .)
    NOT             reduce using rule 25 (expr -> cmd .)
    ENDSTR          reduce using rule 25 (expr -> cmd .)
    COMMA           reduce using rule 25 (expr -> cmd .)
    CLBR            reduce using rule 25 (expr -> cmd .)
    SQCLBR          reduce using rule 25 (expr -> cmd .)
    CUCLBR          reduce using rule 25 (expr -> cmd .)


state 43

    (26) expr -> OPBR . expr CLBR
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 80
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 44

    (38) variable -> VARIABLE .
    (39) variable -> VARIABLE . index
    (59) callfunc -> VARIABLE . OPBR varlist CLBR
    (40) index -> . SQOPBR expr SQCLBR
    (41) index -> . index index

    THEN            reduce using rule 38 (variable -> VARIABLE .)
    error           reduce using rule 38 (variable -> VARIABLE .)
    SUB             reduce using rule 38 (variable -> VARIABLE .)
    ADD             reduce using rule 38 (variable -> VARIABLE .)
    SECOND          reduce using rule 38 (variable -> VARIABLE .)
    FIRST           reduce using rule 38 (variable -> VARIABLE .)
    AND             reduce using rule 38 (variable -> VARIABLE .)
    OR              reduce using rule 38 (variable -> VARIABLE .)
    NOT             reduce using rule 38 (variable -> VARIABLE .)
    ENDSTR          reduce using rule 38 (variable -> VARIABLE .)
    COMMA           reduce using rule 38 (variable -> VARIABLE .)
    CLBR            reduce using rule 38 (variable -> VARIABLE .)
    SQCLBR          reduce using rule 38 (variable -> VARIABLE .)
    CUCLBR          reduce using rule 38 (variable -> VARIABLE .)
    OPBR            shift and go to state 59
    SQOPBR          shift and go to state 61

    index                          shift and go to state 60

state 45

    (35) const -> digit .

    THEN            reduce using rule 35 (const -> digit .)
    error           reduce using rule 35 (const -> digit .)
    SUB             reduce using rule 35 (const -> digit .)
    ADD             reduce using rule 35 (const -> digit .)
    SECOND          reduce using rule 35 (const -> digit .)
    FIRST           reduce using rule 35 (const -> digit .)
    AND             reduce using rule 35 (const -> digit .)
    OR              reduce using rule 35 (const -> digit .)
    NOT             reduce using rule 35 (const -> digit .)
    ENDSTR          reduce using rule 35 (const -> digit .)
    COMMA           reduce using rule 35 (const -> digit .)
    CLBR            reduce using rule 35 (const -> digit .)
    SQCLBR          reduce using rule 35 (const -> digit .)
    CUCLBR          reduce using rule 35 (const -> digit .)


state 46

    (36) const -> bool .

    THEN            reduce using rule 36 (const -> bool .)
    error           reduce using rule 36 (const -> bool .)
    SUB             reduce using rule 36 (const -> bool .)
    ADD             reduce using rule 36 (const -> bool .)
    SECOND          reduce using rule 36 (const -> bool .)
    FIRST           reduce using rule 36 (const -> bool .)
    AND             reduce using rule 36 (const -> bool .)
    OR              reduce using rule 36 (const -> bool .)
    NOT             reduce using rule 36 (const -> bool .)
    ENDSTR          reduce using rule 36 (const -> bool .)
    COMMA           reduce using rule 36 (const -> bool .)
    CLBR            reduce using rule 36 (const -> bool .)
    SQCLBR          reduce using rule 36 (const -> bool .)
    CUCLBR          reduce using rule 36 (const -> bool .)


state 47

    (37) const -> sizeof .

    THEN            reduce using rule 37 (const -> sizeof .)
    error           reduce using rule 37 (const -> sizeof .)
    SUB             reduce using rule 37 (const -> sizeof .)
    ADD             reduce using rule 37 (const -> sizeof .)
    SECOND          reduce using rule 37 (const -> sizeof .)
    FIRST           reduce using rule 37 (const -> sizeof .)
    AND             reduce using rule 37 (const -> sizeof .)
    OR              reduce using rule 37 (const -> sizeof .)
    NOT             reduce using rule 37 (const -> sizeof .)
    ENDSTR          reduce using rule 37 (const -> sizeof .)
    COMMA           reduce using rule 37 (const -> sizeof .)
    CLBR            reduce using rule 37 (const -> sizeof .)
    SQCLBR          reduce using rule 37 (const -> sizeof .)
    CUCLBR          reduce using rule 37 (const -> sizeof .)


state 48

    (47) digit -> INTTYP .

    THEN            reduce using rule 47 (digit -> INTTYP .)
    error           reduce using rule 47 (digit -> INTTYP .)
    SUB             reduce using rule 47 (digit -> INTTYP .)
    ADD             reduce using rule 47 (digit -> INTTYP .)
    SECOND          reduce using rule 47 (digit -> INTTYP .)
    FIRST           reduce using rule 47 (digit -> INTTYP .)
    AND             reduce using rule 47 (digit -> INTTYP .)
    OR              reduce using rule 47 (digit -> INTTYP .)
    NOT             reduce using rule 47 (digit -> INTTYP .)
    ENDSTR          reduce using rule 47 (digit -> INTTYP .)
    COMMA           reduce using rule 47 (digit -> INTTYP .)
    CLBR            reduce using rule 47 (digit -> INTTYP .)
    SQCLBR          reduce using rule 47 (digit -> INTTYP .)
    CUCLBR          reduce using rule 47 (digit -> INTTYP .)


state 49

    (48) digit -> SHORTTYP .

    THEN            reduce using rule 48 (digit -> SHORTTYP .)
    error           reduce using rule 48 (digit -> SHORTTYP .)
    SUB             reduce using rule 48 (digit -> SHORTTYP .)
    ADD             reduce using rule 48 (digit -> SHORTTYP .)
    SECOND          reduce using rule 48 (digit -> SHORTTYP .)
    FIRST           reduce using rule 48 (digit -> SHORTTYP .)
    AND             reduce using rule 48 (digit -> SHORTTYP .)
    OR              reduce using rule 48 (digit -> SHORTTYP .)
    NOT             reduce using rule 48 (digit -> SHORTTYP .)
    ENDSTR          reduce using rule 48 (digit -> SHORTTYP .)
    COMMA           reduce using rule 48 (digit -> SHORTTYP .)
    CLBR            reduce using rule 48 (digit -> SHORTTYP .)
    SQCLBR          reduce using rule 48 (digit -> SHORTTYP .)
    CUCLBR          reduce using rule 48 (digit -> SHORTTYP .)


state 50

    (44) bool -> TRUE .

    THEN            reduce using rule 44 (bool -> TRUE .)
    error           reduce using rule 44 (bool -> TRUE .)
    SUB             reduce using rule 44 (bool -> TRUE .)
    ADD             reduce using rule 44 (bool -> TRUE .)
    SECOND          reduce using rule 44 (bool -> TRUE .)
    FIRST           reduce using rule 44 (bool -> TRUE .)
    AND             reduce using rule 44 (bool -> TRUE .)
    OR              reduce using rule 44 (bool -> TRUE .)
    NOT             reduce using rule 44 (bool -> TRUE .)
    ENDSTR          reduce using rule 44 (bool -> TRUE .)
    COMMA           reduce using rule 44 (bool -> TRUE .)
    CLBR            reduce using rule 44 (bool -> TRUE .)
    SQCLBR          reduce using rule 44 (bool -> TRUE .)
    CUCLBR          reduce using rule 44 (bool -> TRUE .)


state 51

    (45) bool -> FALSE .

    THEN            reduce using rule 45 (bool -> FALSE .)
    error           reduce using rule 45 (bool -> FALSE .)
    SUB             reduce using rule 45 (bool -> FALSE .)
    ADD             reduce using rule 45 (bool -> FALSE .)
    SECOND          reduce using rule 45 (bool -> FALSE .)
    FIRST           reduce using rule 45 (bool -> FALSE .)
    AND             reduce using rule 45 (bool -> FALSE .)
    OR              reduce using rule 45 (bool -> FALSE .)
    NOT             reduce using rule 45 (bool -> FALSE .)
    ENDSTR          reduce using rule 45 (bool -> FALSE .)
    COMMA           reduce using rule 45 (bool -> FALSE .)
    CLBR            reduce using rule 45 (bool -> FALSE .)
    SQCLBR          reduce using rule 45 (bool -> FALSE .)
    CUCLBR          reduce using rule 45 (bool -> FALSE .)


state 52

    (46) bool -> UNDEFINED .

    THEN            reduce using rule 46 (bool -> UNDEFINED .)
    error           reduce using rule 46 (bool -> UNDEFINED .)
    SUB             reduce using rule 46 (bool -> UNDEFINED .)
    ADD             reduce using rule 46 (bool -> UNDEFINED .)
    SECOND          reduce using rule 46 (bool -> UNDEFINED .)
    FIRST           reduce using rule 46 (bool -> UNDEFINED .)
    AND             reduce using rule 46 (bool -> UNDEFINED .)
    OR              reduce using rule 46 (bool -> UNDEFINED .)
    NOT             reduce using rule 46 (bool -> UNDEFINED .)
    ENDSTR          reduce using rule 46 (bool -> UNDEFINED .)
    COMMA           reduce using rule 46 (bool -> UNDEFINED .)
    CLBR            reduce using rule 46 (bool -> UNDEFINED .)
    SQCLBR          reduce using rule 46 (bool -> UNDEFINED .)
    CUCLBR          reduce using rule 46 (bool -> UNDEFINED .)


state 53

    (42) sizeof -> SIZEOF . OPBR type CLBR
    (43) sizeof -> SIZEOF . OPBR variable CLBR

    OPBR            shift and go to state 81


state 54

    (68) dowhile -> DO statement_gr . WHILE expr ENDSTR

    WHILE           shift and go to state 82


state 55

    (69) dowhile -> DO error .

    ENDSTR          reduce using rule 69 (dowhile -> DO error .)
    IF              reduce using rule 69 (dowhile -> DO error .)
    DO              reduce using rule 69 (dowhile -> DO error .)
    FUNCTION        reduce using rule 69 (dowhile -> DO error .)
    VARIABLE        reduce using rule 69 (dowhile -> DO error .)
    MOVE            reduce using rule 69 (dowhile -> DO error .)
    RIGHT           reduce using rule 69 (dowhile -> DO error .)
    LEFT            reduce using rule 69 (dowhile -> DO error .)
    LMS             reduce using rule 69 (dowhile -> DO error .)
    INT             reduce using rule 69 (dowhile -> DO error .)
    BOOL            reduce using rule 69 (dowhile -> DO error .)
    SHORT           reduce using rule 69 (dowhile -> DO error .)
    VECTOROF        reduce using rule 69 (dowhile -> DO error .)
    $end            reduce using rule 69 (dowhile -> DO error .)
    WHILE           reduce using rule 69 (dowhile -> DO error .)
    END             reduce using rule 69 (dowhile -> DO error .)
    ELSE            reduce using rule 69 (dowhile -> DO error .)
    error           reduce using rule 69 (dowhile -> DO error .)
    RETURN          reduce using rule 69 (dowhile -> DO error .)


state 56

    (66) statement_gr -> BEGIN . statement_list END
    (2) statement_list -> . statement_list single_statement
    (3) statement_list -> . single_statement
    (4) single_statement -> . declaration ENDSTR
    (5) single_statement -> . setting ENDSTR
    (6) single_statement -> . if
    (7) single_statement -> . dowhile
    (8) single_statement -> . function
    (9) single_statement -> . callfunc ENDSTR
    (10) single_statement -> . cmd ENDSTR
    (11) single_statement -> . ENDSTR
    (12) declaration -> . type var
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr
    (63) if -> . IF expr THEN statement_gr ELSE statement_gr
    (64) if -> . IF expr THEN statement_gr error
    (65) if -> . IF expr error
    (68) dowhile -> . DO statement_gr WHILE expr ENDSTR
    (69) dowhile -> . DO error
    (70) function -> . FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (29) vectorof -> . VECTOROF type

    ENDSTR          shift and go to state 5
    IF              shift and go to state 14
    DO              shift and go to state 15
    FUNCTION        shift and go to state 16
    VARIABLE        shift and go to state 17
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    statement_list                 shift and go to state 83
    single_statement               shift and go to state 3
    declaration                    shift and go to state 4
    setting                        shift and go to state 6
    if                             shift and go to state 7
    dowhile                        shift and go to state 8
    function                       shift and go to state 9
    callfunc                       shift and go to state 10
    cmd                            shift and go to state 11
    type                           shift and go to state 12
    variable                       shift and go to state 13
    vectorof                       shift and go to state 25

state 57

    (67) statement_gr -> single_statement .

    WHILE           reduce using rule 67 (statement_gr -> single_statement .)
    ELSE            reduce using rule 67 (statement_gr -> single_statement .)
    error           reduce using rule 67 (statement_gr -> single_statement .)
    ENDSTR          reduce using rule 67 (statement_gr -> single_statement .)
    IF              reduce using rule 67 (statement_gr -> single_statement .)
    DO              reduce using rule 67 (statement_gr -> single_statement .)
    FUNCTION        reduce using rule 67 (statement_gr -> single_statement .)
    VARIABLE        reduce using rule 67 (statement_gr -> single_statement .)
    MOVE            reduce using rule 67 (statement_gr -> single_statement .)
    RIGHT           reduce using rule 67 (statement_gr -> single_statement .)
    LEFT            reduce using rule 67 (statement_gr -> single_statement .)
    LMS             reduce using rule 67 (statement_gr -> single_statement .)
    INT             reduce using rule 67 (statement_gr -> single_statement .)
    BOOL            reduce using rule 67 (statement_gr -> single_statement .)
    SHORT           reduce using rule 67 (statement_gr -> single_statement .)
    VECTOROF        reduce using rule 67 (statement_gr -> single_statement .)
    $end            reduce using rule 67 (statement_gr -> single_statement .)
    END             reduce using rule 67 (statement_gr -> single_statement .)
    RETURN          reduce using rule 67 (statement_gr -> single_statement .)


state 58

    (70) function -> FUNCTION VARIABLE . OPBR arrtype CLBR statement_gr RETURN expr ENDSTR

    OPBR            shift and go to state 84


state 59

    (59) callfunc -> VARIABLE OPBR . varlist CLBR
    (60) varlist -> . variable
    (61) varlist -> . const
    (62) varlist -> . varlist COMMA varlist
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    VARIABLE        shift and go to state 35
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    varlist                        shift and go to state 85
    variable                       shift and go to state 86
    const                          shift and go to state 87
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 60

    (39) variable -> VARIABLE index .
    (41) index -> index . index
    (40) index -> . SQOPBR expr SQCLBR
    (41) index -> . index index

    SET             reduce using rule 39 (variable -> VARIABLE index .)
    COMMA           reduce using rule 39 (variable -> VARIABLE index .)
    ENDSTR          reduce using rule 39 (variable -> VARIABLE index .)
    THEN            reduce using rule 39 (variable -> VARIABLE index .)
    error           reduce using rule 39 (variable -> VARIABLE index .)
    SUB             reduce using rule 39 (variable -> VARIABLE index .)
    ADD             reduce using rule 39 (variable -> VARIABLE index .)
    SECOND          reduce using rule 39 (variable -> VARIABLE index .)
    FIRST           reduce using rule 39 (variable -> VARIABLE index .)
    AND             reduce using rule 39 (variable -> VARIABLE index .)
    OR              reduce using rule 39 (variable -> VARIABLE index .)
    NOT             reduce using rule 39 (variable -> VARIABLE index .)
    CLBR            reduce using rule 39 (variable -> VARIABLE index .)
    SQCLBR          reduce using rule 39 (variable -> VARIABLE index .)
    CUCLBR          reduce using rule 39 (variable -> VARIABLE index .)
    SQOPBR          shift and go to state 61

    index                          shift and go to state 88

state 61

    (40) index -> SQOPBR . expr SQCLBR
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 89
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 62

    (74) cmd -> MOVE dir .

    ENDSTR          reduce using rule 74 (cmd -> MOVE dir .)
    THEN            reduce using rule 74 (cmd -> MOVE dir .)
    error           reduce using rule 74 (cmd -> MOVE dir .)
    SUB             reduce using rule 74 (cmd -> MOVE dir .)
    ADD             reduce using rule 74 (cmd -> MOVE dir .)
    SECOND          reduce using rule 74 (cmd -> MOVE dir .)
    FIRST           reduce using rule 74 (cmd -> MOVE dir .)
    AND             reduce using rule 74 (cmd -> MOVE dir .)
    OR              reduce using rule 74 (cmd -> MOVE dir .)
    NOT             reduce using rule 74 (cmd -> MOVE dir .)
    COMMA           reduce using rule 74 (cmd -> MOVE dir .)
    CLBR            reduce using rule 74 (cmd -> MOVE dir .)
    SQCLBR          reduce using rule 74 (cmd -> MOVE dir .)
    CUCLBR          reduce using rule 74 (cmd -> MOVE dir .)


state 63

    (78) dir -> RIGHT .

    ENDSTR          reduce using rule 78 (dir -> RIGHT .)
    THEN            reduce using rule 78 (dir -> RIGHT .)
    error           reduce using rule 78 (dir -> RIGHT .)
    SUB             reduce using rule 78 (dir -> RIGHT .)
    ADD             reduce using rule 78 (dir -> RIGHT .)
    SECOND          reduce using rule 78 (dir -> RIGHT .)
    FIRST           reduce using rule 78 (dir -> RIGHT .)
    AND             reduce using rule 78 (dir -> RIGHT .)
    OR              reduce using rule 78 (dir -> RIGHT .)
    NOT             reduce using rule 78 (dir -> RIGHT .)
    COMMA           reduce using rule 78 (dir -> RIGHT .)
    CLBR            reduce using rule 78 (dir -> RIGHT .)
    SQCLBR          reduce using rule 78 (dir -> RIGHT .)
    CUCLBR          reduce using rule 78 (dir -> RIGHT .)


state 64

    (79) dir -> LEFT .

    ENDSTR          reduce using rule 79 (dir -> LEFT .)
    THEN            reduce using rule 79 (dir -> LEFT .)
    error           reduce using rule 79 (dir -> LEFT .)
    SUB             reduce using rule 79 (dir -> LEFT .)
    ADD             reduce using rule 79 (dir -> LEFT .)
    SECOND          reduce using rule 79 (dir -> LEFT .)
    FIRST           reduce using rule 79 (dir -> LEFT .)
    AND             reduce using rule 79 (dir -> LEFT .)
    OR              reduce using rule 79 (dir -> LEFT .)
    NOT             reduce using rule 79 (dir -> LEFT .)
    COMMA           reduce using rule 79 (dir -> LEFT .)
    CLBR            reduce using rule 79 (dir -> LEFT .)
    SQCLBR          reduce using rule 79 (dir -> LEFT .)
    CUCLBR          reduce using rule 79 (dir -> LEFT .)


state 65

    (15) type -> SHORT INT .

    VARIABLE        reduce using rule 15 (type -> SHORT INT .)
    CLBR            reduce using rule 15 (type -> SHORT INT .)


state 66

    (29) vectorof -> VECTOROF type .

    VARIABLE        reduce using rule 29 (vectorof -> VECTOROF type .)
    CLBR            reduce using rule 29 (vectorof -> VECTOROF type .)


state 67

    (19) var -> var COMMA . var
    (17) var -> . variable
    (18) var -> . setting
    (19) var -> . var COMMA var
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr

    VARIABLE        shift and go to state 35

    var                            shift and go to state 90
    variable                       shift and go to state 33
    setting                        shift and go to state 34

state 68

    (20) setting -> variable SET expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

    ENDSTR          reduce using rule 20 (setting -> variable SET expr .)
    COMMA           reduce using rule 20 (setting -> variable SET expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79


state 69

    (27) setting -> variable SET setarr .
    (31) setarr -> setarr . COMMA setarr

  ! shift/reduce conflict for COMMA resolved as shift
    ENDSTR          reduce using rule 27 (setting -> variable SET setarr .)
    COMMA           shift and go to state 91

  ! COMMA           [ reduce using rule 27 (setting -> variable SET setarr .) ]


state 70

    (30) setarr -> CUOPBR . setarr CUCLBR
    (32) setarr -> CUOPBR . exprarr CUCLBR
    (30) setarr -> . CUOPBR setarr CUCLBR
    (31) setarr -> . setarr COMMA setarr
    (32) setarr -> . CUOPBR exprarr CUCLBR
    (33) exprarr -> . exprarr COMMA exprarr
    (34) exprarr -> . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    CUOPBR          shift and go to state 70
    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    setarr                         shift and go to state 92
    exprarr                        shift and go to state 93
    expr                           shift and go to state 94
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 71

    (63) if -> IF expr THEN . statement_gr ELSE statement_gr
    (64) if -> IF expr THEN . statement_gr error
    (66) statement_gr -> . BEGIN statement_list END
    (67) statement_gr -> . single_statement
    (4) single_statement -> . declaration ENDSTR
    (5) single_statement -> . setting ENDSTR
    (6) single_statement -> . if
    (7) single_statement -> . dowhile
    (8) single_statement -> . function
    (9) single_statement -> . callfunc ENDSTR
    (10) single_statement -> . cmd ENDSTR
    (11) single_statement -> . ENDSTR
    (12) declaration -> . type var
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr
    (63) if -> . IF expr THEN statement_gr ELSE statement_gr
    (64) if -> . IF expr THEN statement_gr error
    (65) if -> . IF expr error
    (68) dowhile -> . DO statement_gr WHILE expr ENDSTR
    (69) dowhile -> . DO error
    (70) function -> . FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (29) vectorof -> . VECTOROF type

    BEGIN           shift and go to state 56
    ENDSTR          shift and go to state 5
    IF              shift and go to state 14
    DO              shift and go to state 15
    FUNCTION        shift and go to state 16
    VARIABLE        shift and go to state 17
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    statement_gr                   shift and go to state 95
    single_statement               shift and go to state 57
    declaration                    shift and go to state 4
    setting                        shift and go to state 6
    if                             shift and go to state 7
    dowhile                        shift and go to state 8
    function                       shift and go to state 9
    callfunc                       shift and go to state 10
    cmd                            shift and go to state 11
    type                           shift and go to state 12
    variable                       shift and go to state 13
    vectorof                       shift and go to state 25

state 72

    (65) if -> IF expr error .

    ENDSTR          reduce using rule 65 (if -> IF expr error .)
    IF              reduce using rule 65 (if -> IF expr error .)
    DO              reduce using rule 65 (if -> IF expr error .)
    FUNCTION        reduce using rule 65 (if -> IF expr error .)
    VARIABLE        reduce using rule 65 (if -> IF expr error .)
    MOVE            reduce using rule 65 (if -> IF expr error .)
    RIGHT           reduce using rule 65 (if -> IF expr error .)
    LEFT            reduce using rule 65 (if -> IF expr error .)
    LMS             reduce using rule 65 (if -> IF expr error .)
    INT             reduce using rule 65 (if -> IF expr error .)
    BOOL            reduce using rule 65 (if -> IF expr error .)
    SHORT           reduce using rule 65 (if -> IF expr error .)
    VECTOROF        reduce using rule 65 (if -> IF expr error .)
    $end            reduce using rule 65 (if -> IF expr error .)
    WHILE           reduce using rule 65 (if -> IF expr error .)
    END             reduce using rule 65 (if -> IF expr error .)
    ELSE            reduce using rule 65 (if -> IF expr error .)
    error           reduce using rule 65 (if -> IF expr error .)
    RETURN          reduce using rule 65 (if -> IF expr error .)


state 73

    (49) math_expr -> expr SUB . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 96
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 74

    (50) math_expr -> expr ADD . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 97
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 75

    (51) math_expr -> expr SECOND . LARGER expr
    (52) math_expr -> expr SECOND . SMALLER expr

    LARGER          shift and go to state 98
    SMALLER         shift and go to state 99


state 76

    (53) math_expr -> expr FIRST . LARGER expr
    (54) math_expr -> expr FIRST . SMALLER expr

    LARGER          shift and go to state 100
    SMALLER         shift and go to state 101


state 77

    (55) math_expr -> expr AND . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 102
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 78

    (56) math_expr -> expr OR . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 103
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 79

    (57) math_expr -> expr NOT . AND expr
    (58) math_expr -> expr NOT . OR expr

    AND             shift and go to state 104
    OR              shift and go to state 105


state 80

    (26) expr -> OPBR expr . CLBR
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

    CLBR            shift and go to state 106
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79


state 81

    (42) sizeof -> SIZEOF OPBR . type CLBR
    (43) sizeof -> SIZEOF OPBR . variable CLBR
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (29) vectorof -> . VECTOROF type

    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VARIABLE        shift and go to state 35
    VECTOROF        shift and go to state 26

    type                           shift and go to state 107
    variable                       shift and go to state 108
    vectorof                       shift and go to state 25

state 82

    (68) dowhile -> DO statement_gr WHILE . expr ENDSTR
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 109
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 83

    (66) statement_gr -> BEGIN statement_list . END
    (2) statement_list -> statement_list . single_statement
    (4) single_statement -> . declaration ENDSTR
    (5) single_statement -> . setting ENDSTR
    (6) single_statement -> . if
    (7) single_statement -> . dowhile
    (8) single_statement -> . function
    (9) single_statement -> . callfunc ENDSTR
    (10) single_statement -> . cmd ENDSTR
    (11) single_statement -> . ENDSTR
    (12) declaration -> . type var
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr
    (63) if -> . IF expr THEN statement_gr ELSE statement_gr
    (64) if -> . IF expr THEN statement_gr error
    (65) if -> . IF expr error
    (68) dowhile -> . DO statement_gr WHILE expr ENDSTR
    (69) dowhile -> . DO error
    (70) function -> . FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (29) vectorof -> . VECTOROF type

    END             shift and go to state 110
    ENDSTR          shift and go to state 5
    IF              shift and go to state 14
    DO              shift and go to state 15
    FUNCTION        shift and go to state 16
    VARIABLE        shift and go to state 17
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    single_statement               shift and go to state 27
    declaration                    shift and go to state 4
    setting                        shift and go to state 6
    if                             shift and go to state 7
    dowhile                        shift and go to state 8
    function                       shift and go to state 9
    callfunc                       shift and go to state 10
    cmd                            shift and go to state 11
    type                           shift and go to state 12
    variable                       shift and go to state 13
    vectorof                       shift and go to state 25

state 84

    (70) function -> FUNCTION VARIABLE OPBR . arrtype CLBR statement_gr RETURN expr ENDSTR
    (71) arrtype -> . type VARIABLE
    (72) arrtype -> . arrtype COMMA arrtype
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (29) vectorof -> . VECTOROF type

    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    arrtype                        shift and go to state 111
    type                           shift and go to state 112
    vectorof                       shift and go to state 25

state 85

    (59) callfunc -> VARIABLE OPBR varlist . CLBR
    (62) varlist -> varlist . COMMA varlist

    CLBR            shift and go to state 113
    COMMA           shift and go to state 114


state 86

    (60) varlist -> variable .

    CLBR            reduce using rule 60 (varlist -> variable .)
    COMMA           reduce using rule 60 (varlist -> variable .)


state 87

    (61) varlist -> const .

    CLBR            reduce using rule 61 (varlist -> const .)
    COMMA           reduce using rule 61 (varlist -> const .)


state 88

    (41) index -> index index .
    (41) index -> index . index
    (40) index -> . SQOPBR expr SQCLBR
    (41) index -> . index index

  ! shift/reduce conflict for SQOPBR resolved as shift
    SET             reduce using rule 41 (index -> index index .)
    COMMA           reduce using rule 41 (index -> index index .)
    ENDSTR          reduce using rule 41 (index -> index index .)
    CLBR            reduce using rule 41 (index -> index index .)
    THEN            reduce using rule 41 (index -> index index .)
    error           reduce using rule 41 (index -> index index .)
    SUB             reduce using rule 41 (index -> index index .)
    ADD             reduce using rule 41 (index -> index index .)
    SECOND          reduce using rule 41 (index -> index index .)
    FIRST           reduce using rule 41 (index -> index index .)
    AND             reduce using rule 41 (index -> index index .)
    OR              reduce using rule 41 (index -> index index .)
    NOT             reduce using rule 41 (index -> index index .)
    SQCLBR          reduce using rule 41 (index -> index index .)
    CUCLBR          reduce using rule 41 (index -> index index .)
    SQOPBR          shift and go to state 61

  ! SQOPBR          [ reduce using rule 41 (index -> index index .) ]

    index                          shift and go to state 88

state 89

    (40) index -> SQOPBR expr . SQCLBR
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

    SQCLBR          shift and go to state 115
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79


state 90

    (19) var -> var COMMA var .
    (19) var -> var . COMMA var

  ! shift/reduce conflict for COMMA resolved as shift
    ENDSTR          reduce using rule 19 (var -> var COMMA var .)
    COMMA           shift and go to state 67

  ! COMMA           [ reduce using rule 19 (var -> var COMMA var .) ]


state 91

    (31) setarr -> setarr COMMA . setarr
    (30) setarr -> . CUOPBR setarr CUCLBR
    (31) setarr -> . setarr COMMA setarr
    (32) setarr -> . CUOPBR exprarr CUCLBR

    CUOPBR          shift and go to state 70

    setarr                         shift and go to state 116

state 92

    (30) setarr -> CUOPBR setarr . CUCLBR
    (31) setarr -> setarr . COMMA setarr

    CUCLBR          shift and go to state 117
    COMMA           shift and go to state 91


state 93

    (32) setarr -> CUOPBR exprarr . CUCLBR
    (33) exprarr -> exprarr . COMMA exprarr

    CUCLBR          shift and go to state 118
    COMMA           shift and go to state 119


state 94

    (34) exprarr -> expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

    CUCLBR          reduce using rule 34 (exprarr -> expr .)
    COMMA           reduce using rule 34 (exprarr -> expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79


state 95

    (63) if -> IF expr THEN statement_gr . ELSE statement_gr
    (64) if -> IF expr THEN statement_gr . error

    ELSE            shift and go to state 120
    error           shift and go to state 121


state 96

    (49) math_expr -> expr SUB expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 49 (math_expr -> expr SUB expr .)
    error           reduce using rule 49 (math_expr -> expr SUB expr .)
    ENDSTR          reduce using rule 49 (math_expr -> expr SUB expr .)
    COMMA           reduce using rule 49 (math_expr -> expr SUB expr .)
    CLBR            reduce using rule 49 (math_expr -> expr SUB expr .)
    SQCLBR          reduce using rule 49 (math_expr -> expr SUB expr .)
    CUCLBR          reduce using rule 49 (math_expr -> expr SUB expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 49 (math_expr -> expr SUB expr .) ]
  ! ADD             [ reduce using rule 49 (math_expr -> expr SUB expr .) ]
  ! SECOND          [ reduce using rule 49 (math_expr -> expr SUB expr .) ]
  ! FIRST           [ reduce using rule 49 (math_expr -> expr SUB expr .) ]
  ! AND             [ reduce using rule 49 (math_expr -> expr SUB expr .) ]
  ! OR              [ reduce using rule 49 (math_expr -> expr SUB expr .) ]
  ! NOT             [ reduce using rule 49 (math_expr -> expr SUB expr .) ]


state 97

    (50) math_expr -> expr ADD expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 50 (math_expr -> expr ADD expr .)
    error           reduce using rule 50 (math_expr -> expr ADD expr .)
    ENDSTR          reduce using rule 50 (math_expr -> expr ADD expr .)
    COMMA           reduce using rule 50 (math_expr -> expr ADD expr .)
    CLBR            reduce using rule 50 (math_expr -> expr ADD expr .)
    SQCLBR          reduce using rule 50 (math_expr -> expr ADD expr .)
    CUCLBR          reduce using rule 50 (math_expr -> expr ADD expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 50 (math_expr -> expr ADD expr .) ]
  ! ADD             [ reduce using rule 50 (math_expr -> expr ADD expr .) ]
  ! SECOND          [ reduce using rule 50 (math_expr -> expr ADD expr .) ]
  ! FIRST           [ reduce using rule 50 (math_expr -> expr ADD expr .) ]
  ! AND             [ reduce using rule 50 (math_expr -> expr ADD expr .) ]
  ! OR              [ reduce using rule 50 (math_expr -> expr ADD expr .) ]
  ! NOT             [ reduce using rule 50 (math_expr -> expr ADD expr .) ]


state 98

    (51) math_expr -> expr SECOND LARGER . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 122
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 99

    (52) math_expr -> expr SECOND SMALLER . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 123
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 100

    (53) math_expr -> expr FIRST LARGER . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 124
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 101

    (54) math_expr -> expr FIRST SMALLER . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 125
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 102

    (55) math_expr -> expr AND expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 55 (math_expr -> expr AND expr .)
    error           reduce using rule 55 (math_expr -> expr AND expr .)
    ENDSTR          reduce using rule 55 (math_expr -> expr AND expr .)
    COMMA           reduce using rule 55 (math_expr -> expr AND expr .)
    CLBR            reduce using rule 55 (math_expr -> expr AND expr .)
    SQCLBR          reduce using rule 55 (math_expr -> expr AND expr .)
    CUCLBR          reduce using rule 55 (math_expr -> expr AND expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 55 (math_expr -> expr AND expr .) ]
  ! ADD             [ reduce using rule 55 (math_expr -> expr AND expr .) ]
  ! SECOND          [ reduce using rule 55 (math_expr -> expr AND expr .) ]
  ! FIRST           [ reduce using rule 55 (math_expr -> expr AND expr .) ]
  ! AND             [ reduce using rule 55 (math_expr -> expr AND expr .) ]
  ! OR              [ reduce using rule 55 (math_expr -> expr AND expr .) ]
  ! NOT             [ reduce using rule 55 (math_expr -> expr AND expr .) ]


state 103

    (56) math_expr -> expr OR expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 56 (math_expr -> expr OR expr .)
    error           reduce using rule 56 (math_expr -> expr OR expr .)
    ENDSTR          reduce using rule 56 (math_expr -> expr OR expr .)
    COMMA           reduce using rule 56 (math_expr -> expr OR expr .)
    CLBR            reduce using rule 56 (math_expr -> expr OR expr .)
    SQCLBR          reduce using rule 56 (math_expr -> expr OR expr .)
    CUCLBR          reduce using rule 56 (math_expr -> expr OR expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 56 (math_expr -> expr OR expr .) ]
  ! ADD             [ reduce using rule 56 (math_expr -> expr OR expr .) ]
  ! SECOND          [ reduce using rule 56 (math_expr -> expr OR expr .) ]
  ! FIRST           [ reduce using rule 56 (math_expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 56 (math_expr -> expr OR expr .) ]
  ! OR              [ reduce using rule 56 (math_expr -> expr OR expr .) ]
  ! NOT             [ reduce using rule 56 (math_expr -> expr OR expr .) ]


state 104

    (57) math_expr -> expr NOT AND . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 126
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 105

    (58) math_expr -> expr NOT OR . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 127
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 106

    (26) expr -> OPBR expr CLBR .

    THEN            reduce using rule 26 (expr -> OPBR expr CLBR .)
    error           reduce using rule 26 (expr -> OPBR expr CLBR .)
    SUB             reduce using rule 26 (expr -> OPBR expr CLBR .)
    ADD             reduce using rule 26 (expr -> OPBR expr CLBR .)
    SECOND          reduce using rule 26 (expr -> OPBR expr CLBR .)
    FIRST           reduce using rule 26 (expr -> OPBR expr CLBR .)
    AND             reduce using rule 26 (expr -> OPBR expr CLBR .)
    OR              reduce using rule 26 (expr -> OPBR expr CLBR .)
    NOT             reduce using rule 26 (expr -> OPBR expr CLBR .)
    ENDSTR          reduce using rule 26 (expr -> OPBR expr CLBR .)
    COMMA           reduce using rule 26 (expr -> OPBR expr CLBR .)
    CLBR            reduce using rule 26 (expr -> OPBR expr CLBR .)
    SQCLBR          reduce using rule 26 (expr -> OPBR expr CLBR .)
    CUCLBR          reduce using rule 26 (expr -> OPBR expr CLBR .)


state 107

    (42) sizeof -> SIZEOF OPBR type . CLBR

    CLBR            shift and go to state 128


state 108

    (43) sizeof -> SIZEOF OPBR variable . CLBR

    CLBR            shift and go to state 129


state 109

    (68) dowhile -> DO statement_gr WHILE expr . ENDSTR
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

    ENDSTR          shift and go to state 130
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79


state 110

    (66) statement_gr -> BEGIN statement_list END .

    WHILE           reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    ELSE            reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    error           reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    ENDSTR          reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    IF              reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    DO              reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    FUNCTION        reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    VARIABLE        reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    MOVE            reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    RIGHT           reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    LEFT            reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    LMS             reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    INT             reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    BOOL            reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    SHORT           reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    VECTOROF        reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    $end            reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    END             reduce using rule 66 (statement_gr -> BEGIN statement_list END .)
    RETURN          reduce using rule 66 (statement_gr -> BEGIN statement_list END .)


state 111

    (70) function -> FUNCTION VARIABLE OPBR arrtype . CLBR statement_gr RETURN expr ENDSTR
    (72) arrtype -> arrtype . COMMA arrtype

    CLBR            shift and go to state 131
    COMMA           shift and go to state 132


state 112

    (71) arrtype -> type . VARIABLE

    VARIABLE        shift and go to state 133


state 113

    (59) callfunc -> VARIABLE OPBR varlist CLBR .

    ENDSTR          reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    THEN            reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    error           reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    SUB             reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    ADD             reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    SECOND          reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    FIRST           reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    AND             reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    OR              reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    NOT             reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    COMMA           reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    CLBR            reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    SQCLBR          reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)
    CUCLBR          reduce using rule 59 (callfunc -> VARIABLE OPBR varlist CLBR .)


state 114

    (62) varlist -> varlist COMMA . varlist
    (60) varlist -> . variable
    (61) varlist -> . const
    (62) varlist -> . varlist COMMA varlist
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    VARIABLE        shift and go to state 35
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    varlist                        shift and go to state 134
    variable                       shift and go to state 86
    const                          shift and go to state 87
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 115

    (40) index -> SQOPBR expr SQCLBR .

    SQOPBR          reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    SET             reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    COMMA           reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    ENDSTR          reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    CLBR            reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    THEN            reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    error           reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    SUB             reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    ADD             reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    SECOND          reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    FIRST           reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    AND             reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    OR              reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    NOT             reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    SQCLBR          reduce using rule 40 (index -> SQOPBR expr SQCLBR .)
    CUCLBR          reduce using rule 40 (index -> SQOPBR expr SQCLBR .)


state 116

    (31) setarr -> setarr COMMA setarr .
    (31) setarr -> setarr . COMMA setarr

  ! shift/reduce conflict for COMMA resolved as shift
    ENDSTR          reduce using rule 31 (setarr -> setarr COMMA setarr .)
    CUCLBR          reduce using rule 31 (setarr -> setarr COMMA setarr .)
    COMMA           shift and go to state 91

  ! COMMA           [ reduce using rule 31 (setarr -> setarr COMMA setarr .) ]


state 117

    (30) setarr -> CUOPBR setarr CUCLBR .

    COMMA           reduce using rule 30 (setarr -> CUOPBR setarr CUCLBR .)
    ENDSTR          reduce using rule 30 (setarr -> CUOPBR setarr CUCLBR .)
    CUCLBR          reduce using rule 30 (setarr -> CUOPBR setarr CUCLBR .)


state 118

    (32) setarr -> CUOPBR exprarr CUCLBR .

    COMMA           reduce using rule 32 (setarr -> CUOPBR exprarr CUCLBR .)
    ENDSTR          reduce using rule 32 (setarr -> CUOPBR exprarr CUCLBR .)
    CUCLBR          reduce using rule 32 (setarr -> CUOPBR exprarr CUCLBR .)


state 119

    (33) exprarr -> exprarr COMMA . exprarr
    (33) exprarr -> . exprarr COMMA exprarr
    (34) exprarr -> . expr
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    exprarr                        shift and go to state 135
    expr                           shift and go to state 94
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 120

    (63) if -> IF expr THEN statement_gr ELSE . statement_gr
    (66) statement_gr -> . BEGIN statement_list END
    (67) statement_gr -> . single_statement
    (4) single_statement -> . declaration ENDSTR
    (5) single_statement -> . setting ENDSTR
    (6) single_statement -> . if
    (7) single_statement -> . dowhile
    (8) single_statement -> . function
    (9) single_statement -> . callfunc ENDSTR
    (10) single_statement -> . cmd ENDSTR
    (11) single_statement -> . ENDSTR
    (12) declaration -> . type var
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr
    (63) if -> . IF expr THEN statement_gr ELSE statement_gr
    (64) if -> . IF expr THEN statement_gr error
    (65) if -> . IF expr error
    (68) dowhile -> . DO statement_gr WHILE expr ENDSTR
    (69) dowhile -> . DO error
    (70) function -> . FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (29) vectorof -> . VECTOROF type

    BEGIN           shift and go to state 56
    ENDSTR          shift and go to state 5
    IF              shift and go to state 14
    DO              shift and go to state 15
    FUNCTION        shift and go to state 16
    VARIABLE        shift and go to state 17
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    statement_gr                   shift and go to state 136
    single_statement               shift and go to state 57
    declaration                    shift and go to state 4
    setting                        shift and go to state 6
    if                             shift and go to state 7
    dowhile                        shift and go to state 8
    function                       shift and go to state 9
    callfunc                       shift and go to state 10
    cmd                            shift and go to state 11
    type                           shift and go to state 12
    variable                       shift and go to state 13
    vectorof                       shift and go to state 25

state 121

    (64) if -> IF expr THEN statement_gr error .

    ENDSTR          reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    IF              reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    DO              reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    FUNCTION        reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    VARIABLE        reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    MOVE            reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    RIGHT           reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    LEFT            reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    LMS             reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    INT             reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    BOOL            reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    SHORT           reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    VECTOROF        reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    $end            reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    WHILE           reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    END             reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    ELSE            reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    error           reduce using rule 64 (if -> IF expr THEN statement_gr error .)
    RETURN          reduce using rule 64 (if -> IF expr THEN statement_gr error .)


state 122

    (51) math_expr -> expr SECOND LARGER expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 51 (math_expr -> expr SECOND LARGER expr .)
    error           reduce using rule 51 (math_expr -> expr SECOND LARGER expr .)
    ENDSTR          reduce using rule 51 (math_expr -> expr SECOND LARGER expr .)
    COMMA           reduce using rule 51 (math_expr -> expr SECOND LARGER expr .)
    CLBR            reduce using rule 51 (math_expr -> expr SECOND LARGER expr .)
    SQCLBR          reduce using rule 51 (math_expr -> expr SECOND LARGER expr .)
    CUCLBR          reduce using rule 51 (math_expr -> expr SECOND LARGER expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 51 (math_expr -> expr SECOND LARGER expr .) ]
  ! ADD             [ reduce using rule 51 (math_expr -> expr SECOND LARGER expr .) ]
  ! SECOND          [ reduce using rule 51 (math_expr -> expr SECOND LARGER expr .) ]
  ! FIRST           [ reduce using rule 51 (math_expr -> expr SECOND LARGER expr .) ]
  ! AND             [ reduce using rule 51 (math_expr -> expr SECOND LARGER expr .) ]
  ! OR              [ reduce using rule 51 (math_expr -> expr SECOND LARGER expr .) ]
  ! NOT             [ reduce using rule 51 (math_expr -> expr SECOND LARGER expr .) ]


state 123

    (52) math_expr -> expr SECOND SMALLER expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .)
    error           reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .)
    ENDSTR          reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .)
    COMMA           reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .)
    CLBR            reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .)
    SQCLBR          reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .)
    CUCLBR          reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .) ]
  ! ADD             [ reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .) ]
  ! SECOND          [ reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .) ]
  ! FIRST           [ reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .) ]
  ! AND             [ reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .) ]
  ! OR              [ reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .) ]
  ! NOT             [ reduce using rule 52 (math_expr -> expr SECOND SMALLER expr .) ]


state 124

    (53) math_expr -> expr FIRST LARGER expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 53 (math_expr -> expr FIRST LARGER expr .)
    error           reduce using rule 53 (math_expr -> expr FIRST LARGER expr .)
    ENDSTR          reduce using rule 53 (math_expr -> expr FIRST LARGER expr .)
    COMMA           reduce using rule 53 (math_expr -> expr FIRST LARGER expr .)
    CLBR            reduce using rule 53 (math_expr -> expr FIRST LARGER expr .)
    SQCLBR          reduce using rule 53 (math_expr -> expr FIRST LARGER expr .)
    CUCLBR          reduce using rule 53 (math_expr -> expr FIRST LARGER expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 53 (math_expr -> expr FIRST LARGER expr .) ]
  ! ADD             [ reduce using rule 53 (math_expr -> expr FIRST LARGER expr .) ]
  ! SECOND          [ reduce using rule 53 (math_expr -> expr FIRST LARGER expr .) ]
  ! FIRST           [ reduce using rule 53 (math_expr -> expr FIRST LARGER expr .) ]
  ! AND             [ reduce using rule 53 (math_expr -> expr FIRST LARGER expr .) ]
  ! OR              [ reduce using rule 53 (math_expr -> expr FIRST LARGER expr .) ]
  ! NOT             [ reduce using rule 53 (math_expr -> expr FIRST LARGER expr .) ]


state 125

    (54) math_expr -> expr FIRST SMALLER expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .)
    error           reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .)
    ENDSTR          reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .)
    COMMA           reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .)
    CLBR            reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .)
    SQCLBR          reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .)
    CUCLBR          reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .) ]
  ! ADD             [ reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .) ]
  ! SECOND          [ reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .) ]
  ! FIRST           [ reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .) ]
  ! AND             [ reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .) ]
  ! OR              [ reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .) ]
  ! NOT             [ reduce using rule 54 (math_expr -> expr FIRST SMALLER expr .) ]


state 126

    (57) math_expr -> expr NOT AND expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 57 (math_expr -> expr NOT AND expr .)
    error           reduce using rule 57 (math_expr -> expr NOT AND expr .)
    ENDSTR          reduce using rule 57 (math_expr -> expr NOT AND expr .)
    COMMA           reduce using rule 57 (math_expr -> expr NOT AND expr .)
    CLBR            reduce using rule 57 (math_expr -> expr NOT AND expr .)
    SQCLBR          reduce using rule 57 (math_expr -> expr NOT AND expr .)
    CUCLBR          reduce using rule 57 (math_expr -> expr NOT AND expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 57 (math_expr -> expr NOT AND expr .) ]
  ! ADD             [ reduce using rule 57 (math_expr -> expr NOT AND expr .) ]
  ! SECOND          [ reduce using rule 57 (math_expr -> expr NOT AND expr .) ]
  ! FIRST           [ reduce using rule 57 (math_expr -> expr NOT AND expr .) ]
  ! AND             [ reduce using rule 57 (math_expr -> expr NOT AND expr .) ]
  ! OR              [ reduce using rule 57 (math_expr -> expr NOT AND expr .) ]
  ! NOT             [ reduce using rule 57 (math_expr -> expr NOT AND expr .) ]


state 127

    (58) math_expr -> expr NOT OR expr .
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SECOND resolved as shift
  ! shift/reduce conflict for FIRST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 58 (math_expr -> expr NOT OR expr .)
    error           reduce using rule 58 (math_expr -> expr NOT OR expr .)
    ENDSTR          reduce using rule 58 (math_expr -> expr NOT OR expr .)
    COMMA           reduce using rule 58 (math_expr -> expr NOT OR expr .)
    CLBR            reduce using rule 58 (math_expr -> expr NOT OR expr .)
    SQCLBR          reduce using rule 58 (math_expr -> expr NOT OR expr .)
    CUCLBR          reduce using rule 58 (math_expr -> expr NOT OR expr .)
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79

  ! SUB             [ reduce using rule 58 (math_expr -> expr NOT OR expr .) ]
  ! ADD             [ reduce using rule 58 (math_expr -> expr NOT OR expr .) ]
  ! SECOND          [ reduce using rule 58 (math_expr -> expr NOT OR expr .) ]
  ! FIRST           [ reduce using rule 58 (math_expr -> expr NOT OR expr .) ]
  ! AND             [ reduce using rule 58 (math_expr -> expr NOT OR expr .) ]
  ! OR              [ reduce using rule 58 (math_expr -> expr NOT OR expr .) ]
  ! NOT             [ reduce using rule 58 (math_expr -> expr NOT OR expr .) ]


state 128

    (42) sizeof -> SIZEOF OPBR type CLBR .

    THEN            reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    error           reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    SUB             reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    ADD             reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    SECOND          reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    FIRST           reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    AND             reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    OR              reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    NOT             reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    ENDSTR          reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    COMMA           reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    CLBR            reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    SQCLBR          reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)
    CUCLBR          reduce using rule 42 (sizeof -> SIZEOF OPBR type CLBR .)


state 129

    (43) sizeof -> SIZEOF OPBR variable CLBR .

    THEN            reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    error           reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    SUB             reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    ADD             reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    SECOND          reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    FIRST           reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    AND             reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    OR              reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    NOT             reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    ENDSTR          reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    COMMA           reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    CLBR            reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    SQCLBR          reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)
    CUCLBR          reduce using rule 43 (sizeof -> SIZEOF OPBR variable CLBR .)


state 130

    (68) dowhile -> DO statement_gr WHILE expr ENDSTR .

    ENDSTR          reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    IF              reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    DO              reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    FUNCTION        reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    VARIABLE        reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    MOVE            reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    RIGHT           reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    LEFT            reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    LMS             reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    INT             reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    BOOL            reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    SHORT           reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    VECTOROF        reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    $end            reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    WHILE           reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    END             reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    ELSE            reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    error           reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)
    RETURN          reduce using rule 68 (dowhile -> DO statement_gr WHILE expr ENDSTR .)


state 131

    (70) function -> FUNCTION VARIABLE OPBR arrtype CLBR . statement_gr RETURN expr ENDSTR
    (66) statement_gr -> . BEGIN statement_list END
    (67) statement_gr -> . single_statement
    (4) single_statement -> . declaration ENDSTR
    (5) single_statement -> . setting ENDSTR
    (6) single_statement -> . if
    (7) single_statement -> . dowhile
    (8) single_statement -> . function
    (9) single_statement -> . callfunc ENDSTR
    (10) single_statement -> . cmd ENDSTR
    (11) single_statement -> . ENDSTR
    (12) declaration -> . type var
    (20) setting -> . variable SET expr
    (27) setting -> . variable SET setarr
    (63) if -> . IF expr THEN statement_gr ELSE statement_gr
    (64) if -> . IF expr THEN statement_gr error
    (65) if -> . IF expr error
    (68) dowhile -> . DO statement_gr WHILE expr ENDSTR
    (69) dowhile -> . DO error
    (70) function -> . FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (29) vectorof -> . VECTOROF type

    BEGIN           shift and go to state 56
    ENDSTR          shift and go to state 5
    IF              shift and go to state 14
    DO              shift and go to state 15
    FUNCTION        shift and go to state 16
    VARIABLE        shift and go to state 17
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    statement_gr                   shift and go to state 137
    single_statement               shift and go to state 57
    declaration                    shift and go to state 4
    setting                        shift and go to state 6
    if                             shift and go to state 7
    dowhile                        shift and go to state 8
    function                       shift and go to state 9
    callfunc                       shift and go to state 10
    cmd                            shift and go to state 11
    type                           shift and go to state 12
    variable                       shift and go to state 13
    vectorof                       shift and go to state 25

state 132

    (72) arrtype -> arrtype COMMA . arrtype
    (71) arrtype -> . type VARIABLE
    (72) arrtype -> . arrtype COMMA arrtype
    (13) type -> . INT
    (14) type -> . BOOL
    (15) type -> . SHORT INT
    (16) type -> . SHORT
    (28) type -> . vectorof
    (29) vectorof -> . VECTOROF type

    INT             shift and go to state 22
    BOOL            shift and go to state 23
    SHORT           shift and go to state 24
    VECTOROF        shift and go to state 26

    arrtype                        shift and go to state 138
    type                           shift and go to state 112
    vectorof                       shift and go to state 25

state 133

    (71) arrtype -> type VARIABLE .

    CLBR            reduce using rule 71 (arrtype -> type VARIABLE .)
    COMMA           reduce using rule 71 (arrtype -> type VARIABLE .)


state 134

    (62) varlist -> varlist COMMA varlist .
    (62) varlist -> varlist . COMMA varlist

  ! shift/reduce conflict for COMMA resolved as shift
    CLBR            reduce using rule 62 (varlist -> varlist COMMA varlist .)
    COMMA           shift and go to state 114

  ! COMMA           [ reduce using rule 62 (varlist -> varlist COMMA varlist .) ]


state 135

    (33) exprarr -> exprarr COMMA exprarr .
    (33) exprarr -> exprarr . COMMA exprarr

  ! shift/reduce conflict for COMMA resolved as shift
    CUCLBR          reduce using rule 33 (exprarr -> exprarr COMMA exprarr .)
    COMMA           shift and go to state 119

  ! COMMA           [ reduce using rule 33 (exprarr -> exprarr COMMA exprarr .) ]


state 136

    (63) if -> IF expr THEN statement_gr ELSE statement_gr .

    ENDSTR          reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    IF              reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    DO              reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    FUNCTION        reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    VARIABLE        reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    MOVE            reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    RIGHT           reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    LEFT            reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    LMS             reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    INT             reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    BOOL            reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    SHORT           reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    VECTOROF        reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    $end            reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    WHILE           reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    END             reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    ELSE            reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    error           reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)
    RETURN          reduce using rule 63 (if -> IF expr THEN statement_gr ELSE statement_gr .)


state 137

    (70) function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr . RETURN expr ENDSTR

    RETURN          shift and go to state 139


state 138

    (72) arrtype -> arrtype COMMA arrtype .
    (72) arrtype -> arrtype . COMMA arrtype

  ! shift/reduce conflict for COMMA resolved as shift
    CLBR            reduce using rule 72 (arrtype -> arrtype COMMA arrtype .)
    COMMA           shift and go to state 132

  ! COMMA           [ reduce using rule 72 (arrtype -> arrtype COMMA arrtype .) ]


state 139

    (70) function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN . expr ENDSTR
    (21) expr -> . variable
    (22) expr -> . const
    (23) expr -> . math_expr
    (24) expr -> . callfunc
    (25) expr -> . cmd
    (26) expr -> . OPBR expr CLBR
    (38) variable -> . VARIABLE
    (39) variable -> . VARIABLE index
    (35) const -> . digit
    (36) const -> . bool
    (37) const -> . sizeof
    (49) math_expr -> . expr SUB expr
    (50) math_expr -> . expr ADD expr
    (51) math_expr -> . expr SECOND LARGER expr
    (52) math_expr -> . expr SECOND SMALLER expr
    (53) math_expr -> . expr FIRST LARGER expr
    (54) math_expr -> . expr FIRST SMALLER expr
    (55) math_expr -> . expr AND expr
    (56) math_expr -> . expr OR expr
    (57) math_expr -> . expr NOT AND expr
    (58) math_expr -> . expr NOT OR expr
    (59) callfunc -> . VARIABLE OPBR varlist CLBR
    (73) cmd -> . MOVE
    (74) cmd -> . MOVE dir
    (75) cmd -> . RIGHT
    (76) cmd -> . LEFT
    (77) cmd -> . LMS
    (47) digit -> . INTTYP
    (48) digit -> . SHORTTYP
    (44) bool -> . TRUE
    (45) bool -> . FALSE
    (46) bool -> . UNDEFINED
    (42) sizeof -> . SIZEOF OPBR type CLBR
    (43) sizeof -> . SIZEOF OPBR variable CLBR

    OPBR            shift and go to state 43
    VARIABLE        shift and go to state 44
    MOVE            shift and go to state 18
    RIGHT           shift and go to state 19
    LEFT            shift and go to state 20
    LMS             shift and go to state 21
    INTTYP          shift and go to state 48
    SHORTTYP        shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    UNDEFINED       shift and go to state 52
    SIZEOF          shift and go to state 53

    expr                           shift and go to state 140
    variable                       shift and go to state 38
    const                          shift and go to state 39
    math_expr                      shift and go to state 40
    callfunc                       shift and go to state 41
    cmd                            shift and go to state 42
    digit                          shift and go to state 45
    bool                           shift and go to state 46
    sizeof                         shift and go to state 47

state 140

    (70) function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr . ENDSTR
    (49) math_expr -> expr . SUB expr
    (50) math_expr -> expr . ADD expr
    (51) math_expr -> expr . SECOND LARGER expr
    (52) math_expr -> expr . SECOND SMALLER expr
    (53) math_expr -> expr . FIRST LARGER expr
    (54) math_expr -> expr . FIRST SMALLER expr
    (55) math_expr -> expr . AND expr
    (56) math_expr -> expr . OR expr
    (57) math_expr -> expr . NOT AND expr
    (58) math_expr -> expr . NOT OR expr

    ENDSTR          shift and go to state 141
    SUB             shift and go to state 73
    ADD             shift and go to state 74
    SECOND          shift and go to state 75
    FIRST           shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    NOT             shift and go to state 79


state 141

    (70) function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .

    ENDSTR          reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    IF              reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    DO              reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    FUNCTION        reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    VARIABLE        reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    MOVE            reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    RIGHT           reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    LEFT            reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    LMS             reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    INT             reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    BOOL            reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    SHORT           reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    VECTOROF        reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    $end            reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    WHILE           reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    END             reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    ELSE            reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    error           reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)
    RETURN          reduce using rule 70 (function -> FUNCTION VARIABLE OPBR arrtype CLBR statement_gr RETURN expr ENDSTR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 69 resolved as shift
WARNING: shift/reduce conflict for SQOPBR in state 88 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 90 resolved as shift
WARNING: shift/reduce conflict for SUB in state 96 resolved as shift
WARNING: shift/reduce conflict for ADD in state 96 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 96 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 96 resolved as shift
WARNING: shift/reduce conflict for AND in state 96 resolved as shift
WARNING: shift/reduce conflict for OR in state 96 resolved as shift
WARNING: shift/reduce conflict for NOT in state 96 resolved as shift
WARNING: shift/reduce conflict for SUB in state 97 resolved as shift
WARNING: shift/reduce conflict for ADD in state 97 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 97 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 97 resolved as shift
WARNING: shift/reduce conflict for AND in state 97 resolved as shift
WARNING: shift/reduce conflict for OR in state 97 resolved as shift
WARNING: shift/reduce conflict for NOT in state 97 resolved as shift
WARNING: shift/reduce conflict for SUB in state 102 resolved as shift
WARNING: shift/reduce conflict for ADD in state 102 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 102 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 102 resolved as shift
WARNING: shift/reduce conflict for AND in state 102 resolved as shift
WARNING: shift/reduce conflict for OR in state 102 resolved as shift
WARNING: shift/reduce conflict for NOT in state 102 resolved as shift
WARNING: shift/reduce conflict for SUB in state 103 resolved as shift
WARNING: shift/reduce conflict for ADD in state 103 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 103 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 103 resolved as shift
WARNING: shift/reduce conflict for AND in state 103 resolved as shift
WARNING: shift/reduce conflict for OR in state 103 resolved as shift
WARNING: shift/reduce conflict for NOT in state 103 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 116 resolved as shift
WARNING: shift/reduce conflict for SUB in state 122 resolved as shift
WARNING: shift/reduce conflict for ADD in state 122 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 122 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 122 resolved as shift
WARNING: shift/reduce conflict for AND in state 122 resolved as shift
WARNING: shift/reduce conflict for OR in state 122 resolved as shift
WARNING: shift/reduce conflict for NOT in state 122 resolved as shift
WARNING: shift/reduce conflict for SUB in state 123 resolved as shift
WARNING: shift/reduce conflict for ADD in state 123 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 123 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 123 resolved as shift
WARNING: shift/reduce conflict for AND in state 123 resolved as shift
WARNING: shift/reduce conflict for OR in state 123 resolved as shift
WARNING: shift/reduce conflict for NOT in state 123 resolved as shift
WARNING: shift/reduce conflict for SUB in state 124 resolved as shift
WARNING: shift/reduce conflict for ADD in state 124 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 124 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 124 resolved as shift
WARNING: shift/reduce conflict for AND in state 124 resolved as shift
WARNING: shift/reduce conflict for OR in state 124 resolved as shift
WARNING: shift/reduce conflict for NOT in state 124 resolved as shift
WARNING: shift/reduce conflict for SUB in state 125 resolved as shift
WARNING: shift/reduce conflict for ADD in state 125 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 125 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 125 resolved as shift
WARNING: shift/reduce conflict for AND in state 125 resolved as shift
WARNING: shift/reduce conflict for OR in state 125 resolved as shift
WARNING: shift/reduce conflict for NOT in state 125 resolved as shift
WARNING: shift/reduce conflict for SUB in state 126 resolved as shift
WARNING: shift/reduce conflict for ADD in state 126 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 126 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 126 resolved as shift
WARNING: shift/reduce conflict for AND in state 126 resolved as shift
WARNING: shift/reduce conflict for OR in state 126 resolved as shift
WARNING: shift/reduce conflict for NOT in state 126 resolved as shift
WARNING: shift/reduce conflict for SUB in state 127 resolved as shift
WARNING: shift/reduce conflict for ADD in state 127 resolved as shift
WARNING: shift/reduce conflict for SECOND in state 127 resolved as shift
WARNING: shift/reduce conflict for FIRST in state 127 resolved as shift
WARNING: shift/reduce conflict for AND in state 127 resolved as shift
WARNING: shift/reduce conflict for OR in state 127 resolved as shift
WARNING: shift/reduce conflict for NOT in state 127 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 134 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 135 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 138 resolved as shift
